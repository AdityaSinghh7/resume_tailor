1. User Authentication & Session
- [x] Implement GitHub OAuth login (backend done).
- [x] On successful login, upsert user info (username, GitHub user ID, access token) into the users table.
- [x] Return a session token to the frontend for authenticated requests.

2. Fetch & Display User Repositories (Frontend)
- [ ] Use the GitHub API (with the user's access token) to fetch the list of user repositories (backend logic exists).
- [ ] Display the list on the frontend, allowing the user to select (tick) which repos to process.
- [ ] Add a 'Process Selected' button to trigger backend ingestion for selected repos.

3. Process Selected Repositories (Backend)
- [x] For each selected repo, fetch repository metadata and store in the projects table, linked to the user.
- [x] Fetch all files (code, README, etc.) via the GitHub API.
- [x] Store file metadata and content in the repository_files table.

4. Chunk & Embed Repository Data (Backend)
- [x] For each file, chunk the content into manageable pieces (by size, function, or paragraph).
- [ ] For each chunk, generate an embedding using the chosen embedding model (e.g., OpenAI, HuggingFace, etc.).
- [ ] Store the chunk, its metadata, and its embedding in the file_chunks table (using pgvector for the embedding column).
- [ ] Group vector embeddings by project for efficient retrieval of top N projects and their related chunks.

5. User Ramble (STAR Write-up)
- [ ] Allow the user to optionally submit a "ramble" (project description in STAR format) for each repo (frontend + backend).
- [ ] Store each ramble as a special chunk in the file_chunks table, with metadata indicating it is a user ramble, and embed it as well.

6. Vector Search & RAG Resume Generation
- [ ] Allow the user to upload a job description and specify N (number of projects to include).
- [ ] Run a semantic search over the vector embeddings to find the N most relevant projects (grouped by project).
- [ ] For each selected project, retrieve all related chunks (including rambles).
- [ ] Generate a project title, 3-4 bullet summary, and include the project URL.
- [ ] Assemble and return a resume-ready object (and optionally, a PDF and alignment score).

7. Re-Processing & Updates
- [ ] Allow users to add new projects or re-process existing ones on demand.
- [ ] Ensure that re-processing does not duplicate data, but updates as needed.

8. RAG Pipeline Implementation
- [ ] After backend and frontend are solid, implement the RAG logic for resume generation.